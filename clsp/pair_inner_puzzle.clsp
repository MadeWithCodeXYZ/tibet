; the code that
; author: yakuhito

; modeled after https://github.com/Uniswap/v1-contracts/blob/master/contracts/uniswap_exchange.vy
;; structure: singleton_top_layer_v1_1 -> p2_merkle_tree -> this puzzle

(mod (
        ; curried in - these will not change with spends
        P2_MERKLE_TREE_MODIFIED_MOD_HASH ; sha256 of the parent module / puzzle (uncurried)
        SINGLETON_STRUCT  ; to quote did_innerpuz.clvm, 
            ;; 'my singleton_struct, formerly a Truth - ((SINGLETON_MOD_HASH, (LAUNCHER_ID, LAUNCHER_PUZZLE_HASH)))'
        P2_SINGLETON_FLASHLOAN_MOD_HASH ; sha256tree of the p2_singleton_flashloan module (uncurried)
        CAT_MOD_HASH ; sha256tree of the cat_v2 module (uncurried)
        LIQUIDITY_TAIL_MOD_HASH ; sha256 tree of the liquidity TAIL (uncurried)
        SETTLEMENT_PAYMENTS_MOD_HASH ; sha256 tree of settlement_payments.clvm (not that it has any curried arguments, but still)

        TAIL_HASH ; identifies the token this pair holds

        ; -- still verified, but given at runtime \/

        new_state_puzzle ; this is verified to be included in the merkle tree in p2_merkle_tree
            ; puzzle returns the new state, CURRIED_ARGS = (liquidity . (xch_reserve token_reserve))
        pair_inner_puzzle_hash
        merkle_root
        state

        ; -- user input \/

        inner_solution ; given by the user
            ; format: (coin_ids . new_state_solution) = ((my_coin_id . (xch_reserve_coin_id . token_reserve_coin_id)) . new_state_solution)
    )
    ; libs
    (include curry.clinc)
    (include condition_codes.clvm)
    (include tibet_utils.clib)

    ; params
    (defun-inline liquidity_from_state (state) (f state))
    (defun-inline xch_reserve_stom_state (state) (f (r state)))
    (defun-inline token_reserve_stom_state (state) (r (r state)))

    ;; deposit/reserve-related
    (defun-inline p2_singleton_puzzle_hash ()
        (curry_hashes_inline P2_SINGLETON_FLASHLOAN_MOD_HASH
            (sha256tree (singleton_mod_hash_from_struct SINGLETON_STRUCT))
            (sha256tree (singleton_launcher_from_struct SINGLETON_STRUCT))
            (sha256tree (singleton_launcher_puzzle_hash_from_struct SINGLETON_STRUCT))
        )
    )

    (defun-inline settlement_announcement (my_coin_id amount)
        (sha256tree
            (list
                my_coin_id
                (list (p2_singleton_puzzle_hash) amount)
            )
        )
    )

    (defun-inline assert_xch_reserve_condition (my_coin_id amount)
        (list
            ASSERT_PUZZLE_ANNOUNCEMENT
            (sha256
                SETTLEMENT_PAYMENTS_MOD_HASH
                (settlement_announcement my_coin_id amount)
            )
        )
    )

    (defun-inline cat_puzzle_hash (tail_hash inner_puzzle_hash)
        (curry_hashes_inline CAT_MOD_HASH
            (sha256tree CAT_MOD_HASH)
            (sha256tree tail_hash)
            inner_puzzle_hash
        )
    )

    (defun-inline settlement_cat_announcement (my_coin_id amount)
        (sha256tree
            (list
                my_coin_id
                (list
                    (p2_singleton_puzzle_hash)
                    amount
                )
            )
        )
    )

    (defun-inline assert_token_reserve_condition (my_coin_id amount)
        (list
            ASSERT_PUZZLE_ANNOUNCEMENT
            (sha256
                (cat_puzzle_hash TAIL_HASH SETTLEMENT_PAYMENTS_MOD_HASH)
                (settlement_cat_announcement
                    my_coin_id
                    amount
                )
            )
        )
    )

    ; liquidity TAIL
    (defun-inline create_liquidity_tokens_condition (liquidity_token_amount liquidity_parent_id liquidity_inner_puzzle_hash keyword)
        (list
            CREATE_PUZZLE_ANNOUNCEMENT
            (sha256
                keyword 
                (calculate_coin_id
                    liquidity_parent_id
                    (cat_puzzle_hash (curry_hashes_inline LIQUIDITY_TAIL_MOD_HASH (sha256tree SINGLETON_STRUCT)) liquidity_inner_puzzle_hash)
                    liquidity_token_amount
                )
                liquidity_token_amount
            )
        )
    )
    
    (defun-inline assert_liquidity_tokens_condition (liquidity_token_amount liquidity_parent_id liquidity_inner_puzzle_hash keyword)
        (list
            ASSERT_COIN_ANNOUNCEMENT
            (sha256
                (calculate_coin_id
                    liquidity_parent_id
                    (cat_puzzle_hash (curry_hashes_inline LIQUIDITY_TAIL_MOD_HASH (sha256tree SINGLETON_STRUCT)) liquidity_inner_puzzle_hash)
                    liquidity_token_amount
                )
                keyword
            )
        )
    )

    ; recreate self

    (defun-inline recreate_self_condition (new_state)
        (list
            CREATE_COIN
            (curry_hashes_inline P2_MERKLE_TREE_MODIFIED_MOD_HASH
                pair_inner_puzzle_hash
                (sha256tree merkle_root)
                (sha256tree new_state)
            )
            1
        )
    )

    ;; this is actually the main function
    ;; (the thing that creates the output conditions)

    ;; another genius idea (thanks, quexington!): do not merge any lists
    ;; use REMARKs instead of conditions instead of not including them at all
    ;; this skips the call(s) to merge_lists, which are expensive since they're recursive functions
    (defun-inline create_output_conditions (
        my_coin_id
        xch_reserve_coin_id
        token_reserve_coin_id

        current_liquidity
        current_xch_reserve
        current_token_reserve

        new_state

        new_liquidity
        new_xch_reserve
        new_token_reserve
        )
        (list
            ; assert my id
            (list ASSERT_MY_COIN_ID my_coin_id)

            ; recreate self
            (recreate_self_condition new_state)

            ; spend XCH reserve, if there is one ('IF I HAD ONE' meme citation required)
            (if (> current_xch_reserve 0)
                (list CREATE_PUZZLE_ANNOUNCEMENT xch_reserve_coin_id)
                ; else
                (list REMARK)
            )
            (if (> current_xch_reserve 0)
                (list ASSERT_COIN_ANNOUNCEMENT (sha256 xch_reserve_coin_id '$'))
                ; else
                (list REMARK)
            )

            ; spend token reserve, if there is one ('IF I HAD ONE' meme citation required)
            (if (> current_token_reserve 0)
                (list CREATE_PUZZLE_ANNOUNCEMENT token_reserve_coin_id)
                ; else
                (list REMARK)
            )
            (if (> current_token_reserve 0)
                (list ASSERT_COIN_ANNOUNCEMENT (sha256 token_reserve_coin_id '$'))
                ; else
                (list REMARK)
            )

            ; assert new XCH reserve
            (if (> new_xch_reserve 0)
                (assert_xch_reserve_condition
                    my_coin_id
                    new_xch_reserve
                )
                ; else
                (list REMARK)
            )

            ; assert new token reserve
            (if (> new_token_reserve 0)
                (assert_token_reserve_condition
                    my_coin_id
                    new_token_reserve
                )
                ; else
                (list REMARK)
            )

            ; additional conditions section of old code (liquidity)

            ; burn liquidity - 2 conditions
            (if (> liquidity new_liquidity)
                ; inner solution is (liquidity_tokens_amount liquidity_inner_puzzle_hash liquidity_parent_id)
                (create_liquidity_tokens_condition
                    (- liquidity new_liquidity) (f (r (r inner_solution))) (f (r inner_solution)) BURN_KEYWORD
                )
                ; else
                (list REMARK)
            )
            (if (> liquidity new_liquidity)
                ; inner solution is (liquidity_tokens_amount liquidity_inner_puzzle_hash liquidity_parent_id)
                (assert_liquidity_tokens_condition
                    (- liquidity new_liquidity) (f (r (r inner_solution))) (f (r inner_solution)) BURN_KEYWORD
                )
                ; else
                (list REMARK)
            )

            ; mint liquidity - also 2 conditions
            (if (> new_liquidity liquidity)
                ; inner solution is (token_amount liquidity_inner_puzzle_hash liquidity_parent_id [xch_amount])
                (create_liquidity_tokens_condition
                    (- new_liquidity liquidity) (f (r (r inner_solution))) (f (r inner_solution)) MINT_KEYWORD
                )
                ; else
                (list REMARK)
            )

            (if (> new_liquidity liquidity)
                ; inner solution is (token_amount liquidity_inner_puzzle_hash liquidity_parent_id [xch_amount])
                (assert_liquidity_tokens_condition
                    (- new_liquidity liquidity) (f (r (r inner_solution))) (f (r inner_solution)) MINT_KEYWORD
                )
                ; else
                (list REMARK)
            )
        )
    )

    ;; stagers

    (defun-inline stager (new_state coin_ids)
        (create_output_conditions
            (f coin_ids)
            (f (r coin_ids))
            (r (r coin_ids))

            (liquidity_from_state state)
            (xch_reserve_stom_state state)
            (token_reserve_stom_state state)

            new_state

            (liquidity_from_state new_state)
            (xch_reserve_stom_state new_state)
            (token_reserve_stom_state new_state)
        )
    )

    (stager
        (a new_state_puzzle (list state (r inner_solution)))
        (f inner_solution)
    )
)